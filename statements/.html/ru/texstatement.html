<!DOCTYPE html
  SYSTEM "html">
<div class="problem-statement">
   <div class="header">
      <h1 class="title">Исправление Опечаток</h1>
      <table>
         <tr class="time-limit">
            <td class="property-title">Ограничение времени</td>
            <td>120&nbsp;секунд</td>
         </tr>
         <tr class="memory-limit">
            <td class="property-title">Ограничение памяти</td>
            <td>1Gb</td>
         </tr>
         <tr class="input-file">
            <td class="property-title">Ввод</td>
            <td colspan="1">стандартный ввод или input.txt</td>
         </tr>
         <tr class="output-file">
            <td class="property-title">Вывод</td>
            <td colspan="1">стандартный вывод или output.txt</td>
         </tr>
      </table>
   </div>
   <h2></h2>
   <div class="legend"><span style="">
         <p>Чтобы хорошо искать нужно хорошо понимать язык, на котором ты ищешь. </p></span><p>Именно по этой причине мы в Яндексе ведём 
         активные разработки в такой отрасли комьютерных наук, как Natural Language Processing
         (Обработка Естественных Языков). И умеем очень многое от простого распознавания того, в какой кодировке и на каком языке написан
         текст, до тематической классификации текста, а также выделения из него объектов реального мира и понимания связей между такими
         объектами. В этой задаче вам предстоит разработать алгоритм решения одной из классических задач NLP, базовые алгоритмы для
         которой сложились еще в 80-х годах прошлого столетия. Это задача исправления опечаток. 
      </p>
   </div>
   <h2>Формат ввода</h2>
   <div class="input-specification"><span style="">
         <p>Формат входного файла очень прост. В первой строке - N, число запросов (не больше 10000). А в каждой следующей строке идут
            запросы пользователей. В отличие от обычных ACM задач мы не гарантируем тепличных условий, когда все слова могут состоять
            только из хороших символов латинского алфавита. Напротив, мы являемся российским поисковиком, а значит и большинство обрабатываемых
            запросов будет на русском. Единственное, что мы гарантируем это то, что запросы идут в кодировке UTF-8 и не содержат символа
            перевода строки.
         </p></span></div>
   <h2>Формат вывода</h2>
   <div class="output-specification"><span style="">
         <p>В выходном файле от вас требуется записать N строк. В каждой строке ваша программа должна вывести либо исправленную версию
            запроса, либо исходный запрос, если считает, что опечатки не было (а такое бывает, ведь не только же безграммотные пользователи
            ищут Яндексом :). 
         </p></span></div>
   <h2>Пример</h2>
   <table class="sample-tests">
      <thead>
         <tr>
            <th>Ввод</th>
            <th>Вывод</th>
         </tr>
      </thead>
      <tbody>
         <tr>
            <td><pre>10
пример
зпах
cfvfz ,tpjgfcyfz ltncrfz buhf
перестре лка
оспект Вернадского
налогоплательщик
гугл
feysbuk
типыданных
однокласники
</pre></td>
            <td><pre>пример
запах
самая безопасная детская игра
перестрелка
проспект Вернадского
налогоплательщик
гугл
facebook
типы данных
одноклассники
</pre></td>
         </tr>
      </tbody>
   </table>
   <h2>Примечания</h2>
   <div class="notes"><span style="">
         <p>Прекрасно понимая, что корректно исправить 100 процентов опечаток - практически невыполнимая задача, мы решили, что AC получает
            абсолютно любая программа, соответствующая выходному формату, но ранжироваться участники будут по показанному их программами
            <a href="http://en.wikipedia.org/wiki/F1_score">F1-скорам</a>. При проверке корректности предложенного исправления, запросы нормализуются
            путём приведения к нижнему регистру, замены всех знаков препинания на пробелы, а также разбитием буквоциферных последовательностей
            на отдельные токены (например "c100" -&gt; "c 100"). С несложным кодом чекера вы можете ознакомиться по 
            <a href="https://github.com/heni/simple-typo-corrector/blob/master/checkers/checker.cpp">ссылке</a>.
            
         </p></span><p>P.S. Для простоты мы уже реализовали <a href="https://github.com/heni/simple-typo-corrector">очень простой вариант</a> 
         программы, исправляющей
         опечатки. Работает она очень просто:
         <ul>
            <li>для начала собираем частотный словарь однословий и двусловий русского языка (взяв в
         качестве репрезентативной выборки собрание сочинения Л.Н. Толстого);</li>
            <li>собранный частотный словарь используем для составления
         соответствующей <a href="http://en.wikipedia.org/wiki/Language_model">языковой модели</a>;</li>
            <li>для каждого запроса генерируем список возможных
         исправлений в нём одной опечатки;</li>
            <li>исправлением запроса считаем ту из сгенерированных на предыдущем шаге гипотез, что имеет
         наибольший вес по собранной языковой модели (если наибольший вес имеет исходный запрос, то считаем, что опечатки в запросе
         не было).</li>
         </ul>
      </p>
   </div>
</div>
